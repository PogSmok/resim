import org.xml.sax.SAXException;

import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.TitledBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import javax.xml.parsers.ParserConfigurationException;
import java.util.*;
import java.awt.Color;

/**
 * Controls GUI generated by the program
 */
public class Window {
    private final JFrame frame;
    private int resourceCount;
    private int[] groupCounts;

    private Queue<Integer>[][] queues;
    private Color[] colors;
    private JPanel[][] queuePanels;
    private JLabel[][] workstationLabels;
    private JLabel[][] timeLabels;
    private int highlight = -1;

    private static final Dimension LABEL_SIZE = new Dimension(100, 25);

    public Window() {
        this.frame = new JFrame("resim");
        this.frame.setExtendedState(JFrame.MAXIMIZED_BOTH); // Maximize to full screen
        this.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.frame.getContentPane().setBackground(Color.BLACK);
    }

    public void welcomeScreen() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(Color.BLACK);
        panel.setBorder(BorderFactory.createEmptyBorder(50, 50, 50, 50)); // padding

        // Title label
        JLabel titleLabel = new JLabel("⚙️ RESIM: Resource Simulation");
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 28));
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Welcome message
        JLabel welcomeLabel = new JLabel("Welcome to the RESIM simulator!");
        welcomeLabel.setFont(new Font("SansSerif", Font.PLAIN, 18));
        welcomeLabel.setForeground(Color.LIGHT_GRAY);
        welcomeLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Prompt
        JLabel promptLabel = new JLabel("Choose how you'd like to provide input data:");
        promptLabel.setFont(new Font("SansSerif", Font.PLAIN, 16));
        promptLabel.setForeground(Color.LIGHT_GRAY);
        promptLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Buttons
        JButton fileButton = new JButton("📂 Load from File");
        JButton manualButton = new JButton("⌨️ Enter Manually");

        Dimension buttonSize = new Dimension(200, 40);
        fileButton.setMaximumSize(buttonSize);
        manualButton.setMaximumSize(buttonSize);

        fileButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        manualButton.setAlignmentX(Component.CENTER_ALIGNMENT);

        fileButton.setFocusPainted(false);
        manualButton.setFocusPainted(false);

        fileButton.setBackground(new Color(60, 120, 180));
        fileButton.setForeground(Color.WHITE);
        manualButton.setBackground(new Color(60, 120, 180));
        manualButton.setForeground(Color.WHITE);

        // Actions
        fileButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            FileNameExtensionFilter filter = new FileNameExtensionFilter("XML Files", "xml");
            fileChooser.setFileFilter(filter);
            int returnValue = fileChooser.showOpenDialog(frame);
            if (returnValue == JFileChooser.APPROVE_OPTION) {
                java.io.File selectedFile = fileChooser.getSelectedFile();
                try {
                    XML file = new XML(selectedFile);
                    Window.this.resourceCount = file.getResourceCount();
                    Window.this.groupCounts = file.getGroupCounts();
                    Window.this.simulate();
                } catch (ParserConfigurationException | SAXException | IOException ex) {
                    JOptionPane.showMessageDialog(frame, "Error loading file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                } catch (Exception ex) {
                    JOptionPane.showMessageDialog(frame, "Unexpected error: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                }
            } else {
                JOptionPane.showMessageDialog(frame, "No file selected.");
            }
        });

        manualButton.addActionListener(e -> {
            JOptionPane.showMessageDialog(frame, "Manual entry not yet implemented.");
            // TODO: Implement manual data entry
        });

        // Add components to panel
        panel.add(titleLabel);
        panel.add(Box.createRigidArea(new Dimension(0, 30)));
        panel.add(welcomeLabel);
        panel.add(Box.createRigidArea(new Dimension(0, 10)));
        panel.add(promptLabel);
        panel.add(Box.createRigidArea(new Dimension(0, 30)));
        panel.add(fileButton);
        panel.add(Box.createRigidArea(new Dimension(0, 15)));
        panel.add(manualButton);

        // Add animated line panel
        AnimatedPanel animation = new AnimatedPanel();
        panel.add(Box.createRigidArea(new Dimension(0, 50)));
        panel.add(animation);

        // Apply panel to frame
        frame.getContentPane().removeAll(); // Clear old content if any
        frame.getContentPane().add(panel);
        frame.revalidate();
        frame.repaint();
        frame.setVisible(true);
    }


    private Color[] assignBrightColors(int[] groupCounts) {
        Random rand = new Random();
        int ids = 0;
        for (int i = 0; i < groupCounts.length; i++) {
            for (int j = 0; j < groupCounts[i]; j++) {
                ids++;
            }
        }

        Color[] colors = new Color[ids];

        for(int i = 0; i < ids; i++) {
            // Generate bright RGB values
            int r = 128 + rand.nextInt(128);
            int g = 128 + rand.nextInt(128);
            int b = 128 + rand.nextInt(128);
            colors[i] = new Color(r, g, b);
        }

        return colors;
    }

    public void simulate() {
        // Clear old UI
        frame.getContentPane().removeAll();
        frame.repaint();

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBackground(Color.BLACK);

        this.queues = new LinkedList[this.resourceCount][this.groupCounts.length];
        for (int i = 0; i < this.resourceCount; i++) {
            for (int j = 0; j < this.groupCounts.length; j++) {
                this.queues[i][j] = new LinkedList<>();
            }
        }
        this.queuePanels = new JPanel[resourceCount][];
        this.workstationLabels = new JLabel[resourceCount][];
        this.timeLabels = new JLabel[resourceCount][];
        this.colors = assignBrightColors(this.groupCounts);

        for (int i = 0; i < resourceCount; i++) {
            JPanel resourcePanel = new JPanel();
            resourcePanel.setLayout(new BoxLayout(resourcePanel, BoxLayout.Y_AXIS));
            TitledBorder border = BorderFactory.createTitledBorder("Resource " + (i + 1));
            border.setTitleColor(Color.WHITE); // Set the title text color
            resourcePanel.setBorder(border);
            resourcePanel.setBackground(Color.DARK_GRAY);
            resourcePanel.setForeground(Color.WHITE);

            // Store resource panels to modify them later when a workstation occupies the resource
            JPanel[] queuePanels = new JPanel[groupCounts.length];
            JLabel[] workstationLabels = new JLabel[groupCounts.length];
            JLabel[] timeLabels = new JLabel[groupCounts.length]; // Track time left for each group

            for (int j = 0; j < groupCounts.length; j++) {
                JPanel queuePanel = new JPanel();
                queuePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 0)); // Arrange horizontally with a little gap
                queuePanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 25));
                queuePanel.setPreferredSize(new Dimension(0, 25)); // Width will grow based on layout
                queuePanel.setBackground(Color.LIGHT_GRAY); // Light background color for the queue panel
                queuePanel.setAlignmentY(Component.CENTER_ALIGNMENT);
                queuePanel.setAlignmentX(Component.LEFT_ALIGNMENT);

                // Default label for the queue panel
                JLabel queueLabel = new JLabel("Queue for Group " + (j + 1));
                queueLabel.setPreferredSize(new Dimension(300, 25)); // Set preferred size
                queueLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK)); // Border around the label
                queuePanel.add(queueLabel);

                queuePanels[j] = queuePanel; // Store queue panel

                JPanel queueRow = new JPanel();
                queueRow.setLayout(new BoxLayout(queueRow, BoxLayout.X_AXIS));
                queueRow.setPreferredSize(new Dimension(900, 30));
                queueRow.setMaximumSize(new Dimension(Short.MAX_VALUE, 30));
                queueRow.setBackground(Color.LIGHT_GRAY);

                JLabel workstationLabel = new JLabel("EMPTY", SwingConstants.CENTER); // Workstation slot
                workstationLabel.setPreferredSize(LABEL_SIZE);
                workstationLabel.setMinimumSize(LABEL_SIZE);
                workstationLabel.setMaximumSize(LABEL_SIZE);
                workstationLabel.setHorizontalAlignment(SwingConstants.CENTER);
                workstationLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));

                workstationLabels[j] = workstationLabel;

                timeLabels[j] = new JLabel("Time Left: 0s");
                timeLabels[j].setBorder(BorderFactory.createLineBorder(Color.BLACK));
                timeLabels[j].setPreferredSize(new Dimension(120, 25));

                queueRow.add(Box.createRigidArea(new Dimension(5, 0)));
                queueRow.add(workstationLabel);
                queueRow.add(Box.createRigidArea(new Dimension(10, 0)));
                queueRow.add(timeLabels[j]);
                queueRow.add(Box.createRigidArea(new Dimension(10, 0)));
                queueRow.add(Box.createHorizontalGlue()); // Pushes queuePanel to expand
                queueRow.add(queuePanel);

                resourcePanel.add(queueRow);
                resourcePanel.add(Box.createRigidArea(new Dimension(0, 5)));
            }

            this.queuePanels[i] = queuePanels;
            this.workstationLabels[i] = workstationLabels;
            this.timeLabels[i] = timeLabels;

            mainPanel.add(resourcePanel);
            mainPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Create a vertical container for the legend
        JPanel legendPanel = new JPanel();
        legendPanel.setLayout(new BoxLayout(legendPanel, BoxLayout.Y_AXIS));
        legendPanel.setBackground(Color.BLACK);

        int id = 0;
        // For each group, create a row (label + color blocks)
        for (int i = 0; i < groupCounts.length; i++) {
            JPanel groupRow = new JPanel(new FlowLayout(FlowLayout.LEFT));
            groupRow.setBackground(Color.BLACK);

            JLabel label = new JLabel("Group " + (i + 1));
            label.setForeground(Color.WHITE);
            label.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 10));
            groupRow.add(label);

            for (int j = 0; j < groupCounts[i]; j++) {
                JLabel legendItem = new JLabel(String.valueOf(id), SwingConstants.CENTER);
                legendItem.setOpaque(true);
                legendItem.setBackground(colors[j]);
                legendItem.setForeground(Color.BLACK);
                legendItem.setPreferredSize(new Dimension(40, 20));
                legendItem.setHorizontalAlignment(SwingConstants.CENTER);
                legendItem.setVerticalAlignment(SwingConstants.CENTER);
                legendItem.setBorder(BorderFactory.createLineBorder(Color.WHITE));
                legendItem.setToolTipText("Highlight this workstation");
                // Add click listener to highlight the corresponding workstation
                int finalId = id;
                legendItem.addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseClicked(MouseEvent e) {
                        if(Window.this.highlight == finalId) Window.this.highlight = -1;
                        else Window.this.highlight = finalId;
                        updateHighlight();
                    }
                });


                groupRow.add(legendItem);
                id++;
            }

            legendPanel.add(groupRow);
        }

        // Add legend panel to the main panel
        mainPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        mainPanel.add(legendPanel);

        // Control buttons at the bottom
        JPanel controlPanel = new JPanel();
        controlPanel.setBackground(Color.BLACK);
        JButton startButton = new JButton("Start");
        JButton terminateButton = new JButton("Terminate");

        // You can attach simulation control logic here:
        startButton.addActionListener(e -> {
            controlPanel.remove(startButton); // Remove from the panel
            controlPanel.revalidate();
            controlPanel.repaint();
            new Simulation(this.resourceCount, this.groupCounts, this);
        });
        terminateButton.addActionListener(e -> System.exit(0));

        controlPanel.add(startButton);
        controlPanel.add(terminateButton);

        mainPanel.add(Box.createRigidArea(new Dimension(0, 20)));
        mainPanel.add(controlPanel);

        JScrollPane scrollPane = new JScrollPane(mainPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        frame.getContentPane().add(scrollPane);
        frame.revalidate();
        frame.repaint();
    }

    private void updateHighlight() {
        // It's currently occupying a resource
        for (JLabel[] workstationLabel : workstationLabels) {
            for (JLabel jLabel : workstationLabel) {
                if (Objects.equals(jLabel.getText(), String.valueOf(highlight))) {
                    jLabel.setBorder(BorderFactory.createLineBorder(Color.RED, 3));
                } else {
                    jLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK)); // Reset all borders
                }
            }
        }

        // It's in a queue
        for(JPanel[] queuePanels : queuePanels) {
            for(JPanel panel : queuePanels) {
                for (Component component : panel.getComponents()) {
                    if (component instanceof JLabel label) {
                        if(Objects.equals(label.getText(), String.valueOf(highlight)))  {
                            label.setBorder(BorderFactory.createLineBorder(Color.RED, 3));
                        } else {
                            label.setBorder(BorderFactory.createLineBorder(Color.BLACK)); // Reset all borders
                        }
                    }
                }
            }
        }
    }

    public void resQueued(int workstationId, int groupID, int resourceID) {
        SwingUtilities.invokeLater(() -> {
            this.queues[resourceID][groupID].offer(workstationId);
            JPanel queuePanel = queuePanels[resourceID][groupID];

            // Clear previous contents
            queuePanel.removeAll();

            for (Integer item : this.queues[resourceID][groupID]) {
                JLabel label = new JLabel(String.valueOf(item), SwingConstants.CENTER);
                label.setOpaque(true);
                label.setBackground(colors[item]);
                label.setForeground(Color.BLACK);
                label.setPreferredSize(new Dimension(30, 20)); // Fixed size
                label.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
                queuePanel.add(label);
            }
            updateHighlight();
            queuePanel.revalidate();
            queuePanel.repaint();
        });
    }

    public void resAcquired(int workstationId, int groupID, int resourceID, int usageTime) {
        SwingUtilities.invokeLater(() -> {
            // Find the workstation label and time left label
            JLabel workstationLabel = workstationLabels[resourceID][groupID]; // Workstation label
            JPanel queuePanel = queuePanels[resourceID][groupID];
            JLabel timeLabel = timeLabels[resourceID][groupID];

            this.queues[resourceID][groupID].poll();

            // Update the UI based on whether the workstation is occupying the resource or is in queue
            workstationLabel.setText(String.valueOf(workstationId)); // Update to show it's occupied
            workstationLabel.setOpaque(true);
            workstationLabel.setBackground(this.colors[workstationId]);
            workstationLabel.setForeground(Color.BLACK);

            timeLabel.setText("Time Left: " + usageTime + "s");
            Timer timer = new Timer(1000, null); // Fire every 1000ms (1s)
            timer.addActionListener(new ActionListener() {
                int timeLeft = usageTime;

                @Override
                public void actionPerformed(ActionEvent e) {
                    timeLeft--;
                    timeLabel.setText("Time Left: " + timeLeft + "s");
                    if (timeLeft <= 0) {
                        timer.stop();
                    }
                }
            });
            timer.start();

            // Clear previous contents
            queuePanel.removeAll();

            for (Integer item : this.queues[resourceID][groupID]) {
                JLabel label = new JLabel(String.valueOf(item), SwingConstants.CENTER);
                label.setOpaque(true);
                label.setBackground(colors[item]);
                label.setForeground(Color.BLACK);
                label.setPreferredSize(new Dimension(30, 20)); // Fixed size
                label.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
                queuePanel.add(label);
            }

            queuePanel.revalidate();
            queuePanel.repaint();
            updateHighlight();
            frame.revalidate();
            frame.repaint();
        });
    }

    public void resReleased(int groupID, int resourceID) {
        SwingUtilities.invokeLater(() -> {
            // Retrieve the UI components
            JLabel workstationLabel = workstationLabels[resourceID][groupID]; // Workstation label

            // Reset the labels
            workstationLabel.setText("EMPTY"); // Mark it as free again
            workstationLabel.setOpaque(false);
            workstationLabel.setForeground(Color.BLACK);
            updateHighlight();
            frame.revalidate();
            frame.repaint();
        });
    }
}
